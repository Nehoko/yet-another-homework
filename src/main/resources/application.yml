spring:
  application:
    name: omno

  threads:
    virtual:
      enabled: true

  datasource:
    url: ${SPRING_DATASOURCE_URL:jdbc:postgresql://postgres.omno.orb.local:5432/pricing}
    username: ${SPRING_DATASOURCE_USERNAME:myuser}
    password: ${SPRING_DATASOURCE_PASSWORD:secret}
    driver-class-name: org.postgresql.Driver
    hikari:
      maximum-pool-size: ${DB_POOL_MAX_SIZE:20}
      minimum-idle: ${DB_POOL_MIN_IDLE:5}
      connection-timeout: ${DB_POOL_CONNECTION_TIMEOUT_MS:20000}
      validation-timeout: ${DB_POOL_VALIDATION_TIMEOUT_MS:5000}
      max-lifetime: ${DB_POOL_MAX_LIFETIME_MS:1800000}

  data:
    redis:
      # Host/port/password are picked from env in containers; these defaults make local compose/swarm work out of the box
      host: ${SPRING_DATA_REDIS_HOST:localhost}
      port: ${SPRING_DATA_REDIS_PORT:6379}
      database: ${SPRING_DATA_REDIS_DATABASE:0}
      client-name: ${SPRING_DATA_REDIS_CLIENT_NAME:${spring.application.name}}
      # Bound Redis client latency so cache does not block request threads
      timeout: ${SPRING_DATA_REDIS_TIMEOUT:50ms}

  jpa:
    hibernate:
      ddl-auto: none
    database: postgresql
    open-in-view: true

  flyway:
    enabled: true
    default-schema: pricing
    create-schemas: true
    locations: classpath:db/migration
    baseline-on-migrate: true

cache:
  # Global cache switch
  enabled: ${CACHE_ENABLED:true}
  # L1 (in-memory Caffeine) cache settings
  l1:
    enabled: ${CACHE_L1_ENABLED:true}
    maximum-size: ${CACHE_L1_MAX_SIZE:10000}    # max entries in local cache
    ttl: ${CACHE_L1_TTL:10m}                    # time-to-live for local cache entries
  # L2 (Redis) cache settings
  l2:
    enabled: ${CACHE_L2_ENABLED:true}
    ttl: ${CACHE_L2_TTL:1h}                     # time-to-live for redis cache entries
    prefix: ${CACHE_L2_PREFIX:}
  refresh:
    soft-ttl-ratio: ${CACHE_REFRESH_SOFT_TTL_RATIO:0.8} # refresh when entry is this fraction of TTL old
  invalidate:
    enabled: ${CACHE_INVALIDATE_ENABLED:true}

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,env,configprops
  endpoint:
    health:
      show-details: when_authorized

  tracing:
    sampling:
      probability: 1.0
    export:
      enabled: true

  otlp:
    metrics:
      export:
        url: http://otel-collector.omno.orb.local:4318/v1/metrics
    tracing:
      endpoint: http://otel-collector.omno.orb.local:4318/v1/traces

logging:
  level:
    root: INFO
    ge.imikhailov.omno.*: DEBUG
  pattern:
    # Adds traceId/spanId to logs for correlation
    level: "%5p [${spring.application.name:},%X{traceId:-},%X{spanId:-}]"

# Resilience4j CircuitBreaker configuration for Redis (L2) cache operations
resilience4j:
  circuitbreaker:
    instances:
      cacheL2:
        registerHealthIndicator: true
        slidingWindowType: COUNT_BASED
        slidingWindowSize: 50
        failureRateThreshold: 50
        slowCallRateThreshold: 50
        slowCallDurationThreshold: 50ms
        permittedNumberOfCallsInHalfOpenState: 5
        waitDurationInOpenState: 30s

# OpenTelemetry Java starter settings.
# We explicitly disable log export because the collector config does not expose a logs pipeline
# and the default OTLP log exporter was spamming 404 errors.
otel:
  service:
    name: ${spring.application.name}
  exporter:
    otlp:
      endpoint: http://otel-collector.omno.orb.local:4318
      protocol: http/protobuf
  logs:
    exporter: none
  metrics:
    exporter: otlp
  traces:
    exporter: otlp
